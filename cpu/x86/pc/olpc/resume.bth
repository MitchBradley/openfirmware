\ See license at end of file
purpose: Low-level code to handle suspend/resume from RAM

command: &builder &this
build-now

\needs start-assembling  fload ${BP}/cpu/x86/asmtools.fth
\needs write-dropin      fload ${BP}/forth/lib/mkdropin.fth

\ create debug-startup

hex

\ fload ${BP}/cpu/x86/pc/report.fth		\ Startup reports for debugging

fload ${BP}/cpu/x86/pc/olpc/config.fth		\ Configuration defines

fload ${BP}/cpu/x86/pc/olpc/startmacros.fth

\ This code will be copied to RAM at suspend-base

\ create save-display
create restore-usb-power

h# fe00.0000 constant gp-pa
h# fe00.4000 constant dc-pa
h# fe00.8000 constant vp-pa
h# fe01.a000 constant ohci-pa
h# fe01.b000 constant ehci-pa
h# efc0.0000 constant uoc-pa
h#      1000 constant gpio-port

start-assembling                                \ Turn on the target assembler
protected-mode

\ Suspend code - called as a subroutine, with return address on the stack
\ This assumes that the following code is in an area that is mapped virtual=physical
\ The assumption is embodied by the fact that paging is turned off on the way
\ down, while continuing to execute straight-line code.  Also, the BP register
\ is used as a memory pointer before and after the paging turn-off.

label suspend-entry   \ h# f.0000 - entry point at fixed location, called by OS
   here h# 10 + #)  jmp   \ Jump to offset 10
   8 pad-to

label resume-entry    \ h# f.0008 - entry point at fixed location, called by resume
   e9 c,  0 ,         \ To be patched later
   nop                \ Aligns to even, for the benefit of the disassembler
   h# 10 pad-to

label suspend-save    \ h# f.0010  (Page directory VA in ax)
   pusha
   pushf  cli
   ds push
   es push
   fs push
   gs push
   ss push dx pop                 \ SS in dx

   here 5 + dup #) call  di pop   \ Virtual address of EIP in DI
   ( here ) asm-base - #  di  sub \ Virtual address of suspend-base in DI

   \ Page directory VA in AX
   ax      si  mov                \ Save PDIR VA
   0 [si]  cx  mov                \ Save old PDIR entry 0
   h# 83 # 0 [ax] mov             \ Punch a 4M mapping 0->0 into the page directory
   cr3 ax mov  ax cr3 mov         \ Invalide the TLB to activate the mapping
   h# f0060 # ax mov  ax jmp      \ Jump to suspend-physical, disabling paging
   h# 60 pad-to

   \ We have to be running from a virtual=physical mapping here, otherwise we
   \ die on the instruction after paging is turned off.
   cr0 ax mov  ax bx mov          \ CR0 saved in BX
   h# 80000000 invert #  ax  and  \ Knock off the Paging enable (PG) bit
   ax cr0 mov                     \ Now paging is off

   \ Physical addresses from now on

\ suspend-physical
\ here suspend-entry put-branch
   resume-data #  bp  mov

\   here 5 + dup #) call  bp pop    \ EIP (virtual) in AX
\   ( here ) asm-base - suspend-base + #  bp  sub
\   resume-data # bp add

   sp      0 [bp]  mov     \ SP part of SP:SS full pointer
   op: dx  4 [bp]  mov     \ SS part of SP:SS full pointer

   h#  6 [bp]  str         \ Task register
   h#  8 [bp]  sldt        \ Local descriptor table register
   h#  a [bp]  sidt        \ Interrupt descriptor table register
   h# 10 [bp]  sgdt        \ Global descriptor table register

               bx  h# 18 [bp]  mov
   cr3 ax mov  ax  h# 1c [bp]  mov
   cr4 ax mov  ax  h# 20 [bp]  mov
               cx  h# 24 [bp]  mov  \ PDIR entry 0
               si  h# 28 [bp]  mov  \ PDIR VA
               di  h# 2c [bp]  mov  \ Address offset

   cld
   h# 38 [bp]  di  lea    \ Save area

   \ Video MSRs that change between VGA and flat panel
   h# 4c00.0014 rmsr  ax stos  dx ax mov  ax stos   \ RSTPLL
   h# 4c00.0015 rmsr  ax stos  dx ax mov  ax stos   \ DOTPLL
   h# c000.2001 rmsr  ax stos  dx ax mov  ax stos   \ Video output format
   h# c000.2011 rmsr  ax stos  dx ax mov  ax stos   \ TFTP pad select

[ifdef] save-display
   \ Freeze image by clearing the DCONLOAD bit (0x800) in the GPIO output register
   h# 0800.0000 h# 1000 port-wl
[then]

   \ Save the GPIO setup   
   \ We do this in top-down order to configure the AUX select
   \ registers before setting the output enables and values.

   gpio-port h# 38 + #  dx  mov  \ Low bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      dx  ax   in   \ Read GPIO control register
      ax stos       \ Save
      4 #  dx  sub  \ Next port address
   loopa

   gpio-port h# 40 + # dx mov  dx ax in  ax stos  \ Pos edge enable
   gpio-port h# 44 + # dx mov  dx ax in  ax stos  \ Neg edge enable
   gpio-port h# 3c + # dx mov  dx ax in  ax stos  \ Low bank lock

   gpio-port h# b8 + #  dx  mov  \ High bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      ax   dx  in   \ Read GPIO control register
      ax stos       \ Save
      4 #  dx  sub  \ Next port address
   loopa

   gpio-port h# c0 + # dx mov  dx ax in  ax stos  \ Pos edge enable
   gpio-port h# c4 + # dx mov  dx ax in  ax stos  \ Neg edge enable
   gpio-port h# bc + # dx mov  dx ax in  ax stos  \ High bank lock

[ifdef] save-display
\ \ h# 3c 0  do  i gp@ l!+  4 +loop  h# 4c gp@ l!+
\  h# f # cx mov  gp-pa set-base  begin  0 [bx] ax mov  ax stos  4 # bx add  loopa
\  gp-pa h# 4c + #) ax mov  ax stos

   vp-pa set-base
   h# 400 reg-save  h# 408 reg-save  h# 418 reg-save
   h#   8 reg-save
   0 # h# 38 [bx] mov  h# 100 # cx mov  begin  h# 40 reg-save  loopa  \ Gamma
   h# 410 reg-save

   dc-pa set-base
   h# 10 reg-save  h# 14 reg-save  h# 18 reg-save  h# 1c reg-save

   h# 20 reg-save  h# 24 reg-save  h# 28 reg-save
   h# 30 reg-save  h# 34 reg-save  h# 38 reg-save
   h# 40 reg-save  h# 44 reg-save  h# 48 reg-save
   h# 50 reg-save  h# 54 reg-save  h# 58 reg-save
   h# 60 reg-save  h# 64 reg-save  h# 68 reg-save
   0 # h# 70 [bx] mov  h# 100 # cx mov  begin  h# 74 reg-save  loopa
   h# 80 reg-save  h# 84 reg-save
   h#  8 reg-save  h#  4 reg-save

[then]

   h# 5140.0034 wmsr         \ Reset PIC shadow pointer (data is irrelevant)
   rdmsr  al stos            \ PIC1 ICW1
   rdmsr  al stos            \ PIC1 ICW2
   rdmsr  al stos            \ PIC1 ICW3
   rdmsr  al stos            \ PIC1 ICW4
   rdmsr  al stos            \ PIC1 OCW2
   rdmsr  al stos            \ PIC1 OCW3

   rdmsr  al stos            \ PIC2 ICW1
   rdmsr  al stos            \ PIC2 ICW2
   rdmsr  al stos            \ PIC2 ICW3
   rdmsr  al stos            \ PIC2 ICW4
   rdmsr  al stos            \ PIC2 OCW2
   rdmsr  al stos            \ PIC2 OCW3

   h# 21 # al in  al stos    \ PIC1 OCW1 (interrupt mask)
   h# a1 # al in  al stos    \ PIC2 OCW1 (interrupt mask)

   h# 4d0 # dx mov  dx al in  al stos   \ Edge/level low
   h# 4d1 # dx mov  dx al in  al stos   \ Edge/level high

   h# 5140.0036 wmsr       \ Reset PIT shadow pointer (data is irrelevant)
   rdmsr  al stos            \ PIT Counter 0 LSB
   rdmsr  al stos            \ PIT Counter 0 MSB
   rdmsr  al stos            \ PIT Counter 1 LSB
   rdmsr  al stos            \ PIT Counter 1 MSB
   rdmsr  al stos            \ PIT Counter 2 LSB
   rdmsr  al stos            \ PIT Counter 2 MSB
   rdmsr  al stos            \ PIT Counter 0 Command Word - not sure how this works
   rdmsr  al stos            \ PIT Counter 1 Command Word
   rdmsr  al stos            \ PIT Counter 2 Command Word
   h# 43 # al in  al stos    \ Read back register 43 directly
   h# 61 # al in  al stos    \ Read back register 43 directly
   h# 5140.0037 rmsr  al stos  \ PIT Count Enable MSR

   \ SMBUS controller
   h# 18b3 # dx mov  \ SMBUS base port
           dx al in   al stos   \ Reg 3
   dx inc  dx al in   al stos   \ Reg 4
   dx inc  dx al in   al bl mov  h# fe # al and  al stos   \ Reg 5 w/o enable bit
   dx inc  dx al in   al stos   \ Reg 6
           bl al mov  al stos   \ Reg 5 with enable bit

   \ MFGPTs 0-5.  MFGPT 6 and 7 are in the standby domain, live during suspend
   h# 1800 # dx mov  \ MFGPT base port
   h# 18 # cx mov    \ Save registers up to h# 30.
   begin
      op: dx ax in
      op: ax stos
      dx inc  dx inc
   loopa

   \ Save CaFe configuration

   h# 6010 config-rl   ax stos  \ NAND BAR
   ax bx mov                    \ Base address
   6  h# 6004 config-ww         \ Enable access
   h# 24 [bx]  ax mov  ax stos  \ NAND Timing1
   h# 28 [bx]  ax mov  ax stos  \ NAND Timing2
   h# 2c [bx]  ax mov  ax stos  \ NAND Timing3
   h# 6004 config-rw   ax stos  \ NAND enables
   
   h# 6110 config-rl   ax stos  \ SDHCI BAR
   ax bx mov                    \ Base address
   h# 3038 [bx] ax mov ax stos  \ GPIO Config
   h# 315c [bx] ax mov ax stos  \ GPIO Data
   h# 6104 config-rw   ax stos  \ SDHCI enables

   h# 6210 config-rl   ax stos  \ Camera BAR
   h# 6204 config-rw   ax stos  \ SDHCI enables

   \ Other state we might want to save:
   \ ISA DMA Controller
   \ AC97
   \ Codec
   \ USB

[ifdef] save-display
   \ Wait until the DCON has loaded a frame - DCONIRQ=1 and DCONSTAT=10
   d# 50,000 # cx mov  \ 50K spins is about 40 mS
   h# 1030 # dx mov
   begin  dx ax in  h# e0 # al and  h# c0 # al cmp  loopne
[then]

   \ Stop video refresh
   h# 4758 #  h# fe00.4000 #)  mov  \ Unlock DC registers
   h#    0 #  h# fe00.4004 #)  mov  \ Turn off access to display memory

   h# 4000.0e00 h# 1410 port-wl   \ Assert SLP_CLK_EN# 1 mS after SUSPA#
   h# 4000.4601 h# 1414 port-wl   \ Release SUSP# 5 mS after wakeup
   h# 4000.00a0 h# 1434 port-wl   \ Turn on WORK_AUX (== MAIN_ON) after 5 mS
   h# 4000.0001 h# 1438 port-wl   \ RESET_OUT turn on delay
   h# 0002.ffff h# 1454 port-wl   \ Clear wakeup type bits

   \ This is actually two 16-bit registers, but 16-bit writes don't work
   \ right (they corrupt other registers) due to a 5536 erratum.  
   h# 1840 port-rl  ( .s cr h# ffff bitset ) ax dx out

   \ The caller chooses the wakeup conditions, so we don't do it here
   \ h# 0100.ffff h# 1840 port-wl   \ Enable Power button wakeup, clear status bits

   wbinvd                                 \ Flush the cache
   h# 00ff.ff00  h# 2000.0018 bitclr-msr  \ Set refresh to 0, disabling GX refresh

   \ This is what the code below does, without the cache alignment elaborations
   \ h#         4. h# 2000.2004 set-msr     \ Enable memory controller clock gating
   \ h#      2000  h# 1848 port-wl          \ go to sleep

   \ Setup the register values in advance so the active instruction sequence
   \ is as short as possible, thus keeping all the activity in one cache line.
   h# 4. # dx mov # ax mov              \ Value to write to MSR
   h# 2000.2004 # cx mov                \ GLD_MSR_PM MSR number
   h# 2000 # bx mov                     \ Value to write to PM1_CNT register
   h# 1848 # di mov                     \ PM1_CNT I/O port number

   \ Align to a cache line boundary
   also forth
   begin  here asm-base - h# 1f and  while  h# 90 c,  repeat  \ Align with NOPs
   previous

   wrmsr                                \ Write GLD_MSR_PM to self-refresh memory
   di dx mov  bx ax mov  ax dx out      \ Write PM1_CNT to initial suspend

   begin again    \ Spin in this cache line while going down

\ Resume code
here resume-entry put-branch

\ Assumptions:
\   Processor is in protected mode
\   Running from a 32-bit identity-mapped code segment
\   Using physical addresses

\ char < 3f8 port-wb  begin  3fd port-rb 20 bitand  0<> until

   resume-data #  bp  mov

   cld

   \ MSR init
   h# 30 [bp]  si  mov   \ MSR table start address
   si          bx  mov
   h# 34 [bp]  bx  add   \ MSR table end address

   begin
      ax lods  ax cx  mov   \ msr#
      ax lods  ax dx  mov   \ msr.hi
      ax lods               \ msr.lo
      wrmsr
      si bx cmp
   = until

   h# 1840 # di mov         \ PM1_STS/EN I/O port number
   di ax in  ax di out      \ Preserve EN bits and cleare STS bits  

   h# 38 [bp]  si  lea    \ Save area

   ax lods  ax dx xchg  ax lods  ax dx xchg  h# 4c00.0014 wmsr  \ RSTPLL
   ax lods  ax dx xchg  ax lods  ax dx xchg
   1 bitset  h# 4c00.0015 wmsr  \ DOTPLL - reset to make it take the new value
   1 bitclr  h# 4c00.0015 wmsr  \ DOTPLL - release reset
   ax lods  ax dx xchg  ax lods  ax dx xchg  h# c000.2001 wmsr  \ Video output format
   ax lods  ax dx xchg  ax lods  ax dx xchg  h# c000.2011 wmsr  \ TFTP pad select

   h# 1038 #     dx  mov  \ Low bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      ax lods
      ax   dx  out  \ Write to GPIO control register
      4 #  dx  sub  \ Next port address
   loopa
   ax lods  h# 1040 # dx mov  ax dx out  \ Pos edge enable
   ax lods  h# 1044 # dx mov  ax dx out  \ Neg edge enable
   ax lods  h# 103c # dx mov  ax dx out  \ Low bank lock

   h# 10b8 #     dx  mov  \ High bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      ax lods
      ax   dx  out  \ Write to GPIO control register
      4 #  dx  sub  \ Next port address
   loopa
   ax lods  h# 10c0 # dx mov  ax dx out  \ Pos edge enable
   ax lods  h# 10c4 # dx mov  ax dx out  \ Neg edge enable
   ax lods  h# 10bc # dx mov  ax dx out  \ High bank lock

[ifdef] save-display

\ \ h# 3c 0  do  l@+ i gp!  4 +loop   l@+ h# 4c gp! 
\  h# f # cx mov   gp-pa set-base  begin  ax lods  ax 0 [bx] mov  4 # bx add  loopa
\  ax lods  ax  gp-pa h# 4c + #)  mov

\ Synchronize the flat panel turn-on with the DCON blanking
\   d# 50,000 # cx mov  \ 50K spins is about 40 mS
\   h# 1030 # dx mov  \ GPIO data port
\   begin  dx ax in  h# 1000 # ax test  loope  \ Wait for blanking

   vp-pa set-base
   0 #  h# 50 [bx] mov  \ Power on for DACs, enable gamma correction 
   h# 400 reg-restore
   h# 408 reg-restore
   h# 418 reg-restore
   h#   8 reg-restore
   0 #  h# 38 [bx] mov  h# 100 # cx mov  begin  h# 40 reg-restore  loopa  \ Gamma
   h# 410 reg-restore

\   d# 1,000,000 # cx mov  begin  h# 410 [bx] ax mov  1 # al test  loope  \ Panel power up

   dc-pa set-base
   
   h# 4758 #  0 [bx]  mov  \ Unlock
   h# 10 reg-restore   h# 14 reg-restore   h# 18 reg-restore   h# 1c reg-restore

   h# 20 reg-restore   h# 24 reg-restore   h# 28 reg-restore
   h# 30 reg-restore   h# 34 reg-restore   h# 38 reg-restore
   h# 40 reg-restore   h# 44 reg-restore   h# 48 reg-restore
   h# 50 reg-restore   h# 54 reg-restore   h# 58 reg-restore
   h# 60 reg-restore   h# 64 reg-restore   h# 68 reg-restore
   0 #  h# 70  [bx] mov   h# 100 # cx mov   begin  h# 74 reg-restore  loopa
   h# 80 reg-restore   h# 84 reg-restore

\ Synchronize the VGA turn-on with the DCON blanking
   d# 50,000 # cx mov  \ 50K spins is about 40 mS
   h# 1030 # dx mov  \ GPIO data port
   begin  dx ax in  h# 1000 # ax test  loope  \ Wait for blanking

   h#  8 reg-restore   h#  4 reg-restore

   0 #  dc-pa #)  mov  \ Lock

\   d# 100,000 # cx mov  begin  h# 80 #  ax in  loopa  \ Delay about 100 ms

   d# 80,000 # cx mov  begin  h# 80 # a in  loopa  \ Wait for panel power up

   \ Unfreeze image by setting the DCONLOAD bit (0x800) in the GPIO output register
   h# 0800 h# 1000 port-wl
[then]

\   0 h# 1842 pw!   \ Disable power button during early startup

   \ Restore Interrupt controller setup
   al lods        al h# 20 # out    \ PIC1 ICW1
   al lods        al h# 21 # out    \ PIC1 ICW2
   al lods        al h# 21 # out    \ PIC1 ICW3
   al lods        al h# 21 # out    \ PIC1 ICW4
   al lods        al h# 20 # out    \ PIC1 OCW2
   h# c0 # al or  al h# 20 # out    \ PIC1 OCW2'
   al lods        al h# 20 # out    \ PIC1 OCW3

   al lods        al h# a0 # out    \ PIC2 ICW1
   al lods        al h# a1 # out    \ PIC2 ICW2
   al lods        al h# a1 # out    \ PIC2 ICW3
   al lods        al h# a1 # out    \ PIC2 ICW4
   al lods        al h# a0 # out    \ PIC2 OCW2
   h# c0 # al or  al h# a0 # out    \ PIC2 OCW2'
   al lods        al h# a0 # out    \ PIC2 OCW3

   al lods  al  h# 21 #  out   \ PIC1 OCW1 (interrupt mask)
   al lods  al  h# a1 #  out   \ PIC2 OCW1 (interrupt mask)

   al lods  h# 4d0 # dx mov  al dx out   \ Edge/level low
   al lods  h# 4d1 # dx mov  al dx out   \ Edge/level high

   \ Restore PIT (timer)
   h# 30 # al mov  al h# 43 # out  \ Load LSB,MSB for counter 0
   al lods  al h# 40 out
   al lods  al h# 40 out
   h# 70 # al mov  al h# 43 # out  \ Load LSB,MSB for counter 1
   al lods  al h# 41 out
   al lods  al h# 41 out
   h# b0 # al mov  al h# 43 # out  \ Load LSB,MSB for counter 2
   al lods  al h# 42 # out
   al lods  al h# 42 # out
   al lods  \ Command word for counter 0
   al lods  \ Command word for counter 1
   al lods  \ Command word for counter 2
   al lods  al h# 43 # out
   al lods  al h# 61 # out
   al lods  h# 5140.0037 wmsr   \ PIT Count Enable MSR - high bits irrelevant

   \ SMBUS controller
   h# 18b3 # dx mov  \ SMBUS base port
   al lods          al dx out  \ Reg 3
   al lods  dx inc  al dx out  \ Reg 4
   al lods  dx inc  al dx out  \ Reg 5 without the enable bit
   al lods  dx inc  al dx out  \ Reg 6
   al lods  dx dec  al dx out  \ Reg 5 with the enable bit

   \ MFGPTs 0-5.  MFGPT 6 and 7 are in the standby domain, live during suspend
   h# 1800 # dx mov  \ MFGPT base port
   h# 18 # cx mov
   begin
      op: ax lods  ax ax test  0<>  if  op: ax dx out  then
      dx inc  dx inc
   loopa

   \ AC97
   \ Codec

   \ h# 8000 h# 4000.0000 or h# 1440 pl!  \ Fail-safe delay

   \ USB Power-to-Port assignment
   h# 3ab #  uoc-pa     #) mov
   h#   2 #  uoc-pa 4 + #) mov

[ifdef] restore-usb-power
   ohci-pa set-base
   h#       1 #  h# 08 [bx]  mov  \ HcCommandStatus register - Reset host controller
   h# 1e.0000 #  h# 4c [bx]  mov  \ HcRhDescriptorB register - Individual port power
   h#     100 #  h# 58 [bx]  mov  \ HcRhPortStatus[2] register - Power on
[then]

   \ Restore CaFe configuration

   h# 6010 config-setup  ax lods  ax dx out        \ NAND BAR
   ax bx mov                                       \ Base address
   6  h# 6004 config-ww                            \ Enable access
   ax lods  ax  h# 24 [bx]  mov                    \ NAND Timing 1
   ax lods  ax  h# 28 [bx]  mov                    \ NAND Timing 2
   ax lods  ax  h# 2c [bx]  mov                    \ NAND Timing 3
   h# 6004 config-setup  ax lods  op: ax dx out    \ NAND enables

   h# 6110 config-setup  ax lods  ax dx out        \ SDHCI BAR
   ax bx mov                                       \ Base address
   6  h# 6104 config-ww                            \ Enable access
   ax lods  ax  h# 3038 [bx]  mov                  \ GPIO Config
   ax lods  ax  h# 315c [bx]  mov                  \ GPIO Data
   \ The next two values can't be saved/restored; the registers aren't readable
   op: h# 0004 #  h# 6a [bx]  mov                  \ Magic recipe from Marvell
   op: h# 7fff #  h# 60 [bx]  mov                  \ Magic recipe from Marvell
   h# 6104 config-setup  ax lods  op: ax dx out    \ SDHCI enables

   h# 6210 config-setup  ax lods  ax dx out        \ Camera BAR
   h# 6204 config-setup  ax lods  op: ax dx out    \ Camera enables

[ifdef] restore-usb-power
   ohci-pa set-base
   \ Do this after the CaFe setup to stagger the power-on.  The staggering
   \ might not be necessary for B3 and later.
   h#     100 #  h# 54 [bx]  mov  \ HcRhPortStatus[1] register - Power on
   \ Ports 2 and 3 are ganged and port 4 (wireless) is controlled by EC,
   \ but we still want the "powered" bits to be set in the registers
   h#     100 #  h# 5c [bx]  mov  \ HcRhPortStatus[3] register - Power on
   h#     100 #  h# 60 [bx]  mov  \ HcRhPortStatus[4] register - Power on
[then]

   \ Display stuff
   h# 4758 #  h# fe00.4000 #)  mov  \ Unlock display controller registers

   h# 1808 rmsr              \ Get default region config register - low in ax
   d#  8 # ax shr            \ Discard region type bits
   d# 12 # ax shl            \ Convert page number to address
   ax  h# fe00.4088 #)  mov  \ DV_CTL register - sets framebuffer phys base

   h# fd00.0000 #  h# fe00.4084 #)  mov   \ GLIU0 Memory offset
   h# fd00.0000 #  h# fe00.004c #)  mov   \ GP base
   h# fd80.0000 #  h# fe00.8460 #)  mov   \ Flat panel base

   \ There is a lot of other stuff that must be done to turn on the
   \ video - but we will let the gx driver take care of that.

   \ XXX keyboard init
   \ DCON fiddling
   \ USB

   h# 2c [bp]  di mov               \ VA of suspend-base in di
   h# 28 [bp]  si mov               \ PDIR VA
   h# 24 [bp]  cx mov               \ PDIR entry 0
   h# 20 [bp]  ax mov  ax cr4 mov  
   h# 1c [bp]  ax mov  ax cr3 mov  
   h# 18 [bp]  ax mov

   h# 10 [bp]  lgdt        \ Global descriptor table register
   h#  a [bp]  lidt        \ Interrupt descriptor table register
   h#  8 [bp]  lldt        \ Local descriptor table register
   op:  h# ffff #  h# 6 [bp]  test  0<>  if
\     h#  6 [bp]  ltr      \ Task register
   then

   ax cr0 mov              \ Paging is back on now (if it ever was on)

   \ Force the paging enable to take place
   h# eb asm8,  0 asm8,    \ jmp to next location to enable paging

   \ Now jump back to the virtual execution address
   here asm-base - 8 + # di add  \ The add instruction is 6 bytes, the jmp is 2
   di jmp

   \ Identity mapping of low memory is still in effect
   0 [bp]  sp  lss

   cx  0 [si]  mov         \ Restore PDIR entry 0
   cr3 ax mov  ax cr3 mov  \ Flush TLB

   \ Identity mapping of low memory might not exist now

\  char > 3f8 port-wb  begin  3fd port-rb 20 bitand  0<> until

   gs pop

   fs pop
   es pop
   ds pop
   popf
   popa
   ret
end-code


writing resume.di
suspend-entry here over -  0  " resume"  write-dropin
ofd @ fclose

\ To use task state switching, we need to do:
\ ??? how to pass information to a task?
\  Set up a 108-byte Task State Segment containing:
\    Initial values for general registers and segment registers
\    EFLAGS value
\    EIP value
\    CR3 value for firmware
\    Stack addresses for 3 privilege levels
\    Task LDT value (0?)
\ Create a TSS descriptor referring to the Task State Segment - it goes in the GDT
\ Do an LTR with that descriptor
\ The TSS can be paged.  Gag.

\ Could allocate additional space in the TSS for the save/restore data

\ Arrange for Linux to import the descriptor
\ Linux does a task call to suspend

\ The resume code also needs to do an LTR to get back to the descriptor
