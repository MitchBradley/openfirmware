\ See license at end of file
purpose: Low-level code to handle suspend/resume from RAM

command: &builder &this
build-now

\needs start-assembling  fload ${BP}/cpu/x86/asmtools.fth
\needs write-dropin      fload ${BP}/forth/lib/mkdropin.fth

\ create debug-startup

hex

\ fload ${BP}/cpu/x86/pc/report.fth		\ Startup reports for debugging

fload ${BP}/cpu/x86/pc/olpc/config.fth		\ Configuration defines

fload ${BP}/cpu/x86/pc/olpc/startmacros.fth

\ This code will be copied to RAM at suspend-base

start-assembling                                \ Turn on the target assembler
protected-mode

\ Suspend code - called as a subroutine, with return address on the stack
\ This assumes that the following code is in an area that is mapped virtual=physical
\ The assumption is embodied by the fact that paging is turned off on the way
\ down, while continuing to execute straight-line code.  Also, the BP register
\ is used as a memory pointer before and after the paging turn-off.

label suspend-entry   \ h# f.0000 - entry point at fixed location, called by OS
   here h# 10 + #)  jmp   \ Jump to offset 10
   8 pad-to

label resume-entry    \ h# f.0008 - entry point at fixed location, called by resume
   e9 c,  0 ,         \ To be patched later
   nop                \ Aligns to even, for the benefit of the disassembler
   h# 10 pad-to

label suspend-save    \ h# f.0010
   pusha
   pushf
   ds push
   es push
   fs push
   gs push
   ss push dx pop                 \ SS in dx

   cr0 ax mov  ax bx mov          \ CR0 in BX
   h# 80000000 invert #  ax  and  \ Paging enable off
   ax cr0 mov

   h# f0030 # ax mov  ax jmp      \ Jump to suspend-physical, disabling paging

   h# 30 pad-to

\ suspend-physical
\ here suspend-entry put-branch
   resume-data #  bp  mov

   sp      0 [bp]  mov     \ SP part of SP:SS full pointer
   op: dx  4 [bp]  mov     \ SS part of SP:SS full pointer

   h#  6 [bp]  str         \ Task register
   h#  8 [bp]  sldt        \ Local descriptor table register
   h#  a [bp]  sidt        \ Interrupt descriptor table register
   h# 10 [bp]  sgdt        \ Global descriptor table register

               bx  h# 18 [bp]  mov
   cr3 ax mov  ax  h# 1c [bp]  mov
   cr4 ax mov  ax  h# 20 [bp]  mov

   \ Physical addresses from now on

   cld
   h# 38 [bp]  di  lea    \ Save area

   \ Video MSRs that change between VGA and flat panel
   h# 4c00.0014 rmsr  ax stos  dx ax mov  ax stos   \ RSTPLL
   h# 4c00.0015 rmsr  ax stos  dx ax mov  ax stos   \ DOTPLL
   h# c000.2001 rmsr  ax stos  dx ax mov  ax stos   \ Video output format
   h# c000.2011 rmsr  ax stos  dx ax mov  ax stos   \ TFTP pad select

   \ Save the GPIO setup   
   \ We do this in top-down order to configure the AUX select
   \ registers before setting the output enables and values.

   h# 1038 #     dx  mov  \ Low bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      dx  ax   in   \ Read GPIO control register
      ax stos       \ Save
      4 #  dx  sub  \ Next port address
   loopne

   h# 1040 # dx mov  dx ax in  ax stos  \ Pos edge enable
   h# 1044 # dx mov  dx ax in  ax stos  \ Neg edge enable
   h# 103c # dx mov  dx ax in  ax stos  \ Low bank lock

   h# 10b8 #     dx  mov  \ High bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      ax   dx  in   \ Read GPIO control register
      ax stos       \ Save
      4 #  dx  sub  \ Next port address
   loopne

   h# 10c0 # dx mov  dx ax in  ax stos  \ Pos edge enable
   h# 10c4 # dx mov  dx ax in  ax stos  \ Neg edge enable
   h# 10bc # dx mov  dx ax in  ax stos  \ High bank lock

   h# 5140.0034 wmsr         \ Reset PIC shadow pointer (data is irrelevant)
   rdmsr  al stos            \ PIC1 ICW1
   rdmsr  al stos            \ PIC1 ICW2
   rdmsr  al stos            \ PIC1 ICW3
   rdmsr  al stos            \ PIC1 ICW4
   rdmsr  al stos            \ PIC1 OCW2
   rdmsr  al stos            \ PIC1 OCW3

   rdmsr  al stos            \ PIC2 ICW1
   rdmsr  al stos            \ PIC2 ICW2
   rdmsr  al stos            \ PIC2 ICW3
   rdmsr  al stos            \ PIC2 ICW4
   rdmsr  al stos            \ PIC2 OCW2
   rdmsr  al stos            \ PIC2 OCW3

   h# 21 # al in  al stos    \ PIC1 OCW1 (interrupt mask)
   h# a1 # al in  al stos    \ PIC2 OCW1 (interrupt mask)

   h# 4d0 # dx mov  dx al in  al stos   \ Edge/level low
   h# 4d1 # dx mov  dx al in  al stos   \ Edge/level high

   h# 5140.0036 wmsr       \ Reset PIT shadow pointer (data is irrelevant)
   rdmsr  al stos            \ PIT Counter 0 LSB
   rdmsr  al stos            \ PIT Counter 0 MSB
   rdmsr  al stos            \ PIT Counter 1 LSB
   rdmsr  al stos            \ PIT Counter 1 MSB
   rdmsr  al stos            \ PIT Counter 2 LSB
   rdmsr  al stos            \ PIT Counter 2 MSB
   rdmsr  al stos            \ PIT Counter 0 Command Word - not sure how this works
   rdmsr  al stos            \ PIT Counter 1 Command Word
   rdmsr  al stos            \ PIT Counter 2 Command Word
   h# 43 # al in  al stos    \ Read back register 43 directly
   h# 61 # al in  al stos    \ Read back register 43 directly
   h# 5140.0037 rmsr  al stos  \ PIT Count Enable MSR

   \ SMBUS controller
   h# 18b3 # dx mov  \ SMBUS base port
           dx al in   al stos   \ Reg 3
   dx inc  dx al in   al stos   \ Reg 4
   dx inc  dx al in   al bl mov  h# fe # al and  al stos   \ Reg 5 w/o enable bit
   dx inc  dx al in   al stos   \ Reg 6
           bl al mov  al stos   \ Reg 5 with enable bit

   \ MFGPTs 0-5.  MFGPT 6 and 7 are in the standby domain, live during suspend
   h# 1800 # dx mov  \ MFGPT base port
   h# 18 # cx mov    \ Save registers up to h# 30.
   begin
      op: dx ax in
      op: ax stos
      dx inc  dx inc
   loopa

   \ Save CaFe configuration

   h# 6010 config-rl   ax stos  \ NAND BAR
   ax bx mov                    \ Base address
   6  h# 6004 config-ww         \ Enable access
   h# 24 [bx]  ax mov  ax stos  \ NAND Timing1
   h# 28 [bx]  ax mov  ax stos  \ NAND Timing2
   h# 2c [bx]  ax mov  ax stos  \ NAND Timing3
   h# 6004 config-rw   ax stos  \ NAND enables
   
   h# 6110 config-rl   ax stos  \ SDHCI BAR
   ax bx mov                    \ Base address
   h# 3038 [bx] ax mov ax stos  \ GPIO Config
   h# 315c [bx] ax mov ax stos  \ GPIO Data
   h# 6104 config-rw   ax stos  \ SDHCI enables

   h# 6210 config-rl   ax stos  \ Camera BAR
   h# 6204 config-rw   ax stos  \ SDHCI enables

   \ Other state we might want to save:
   \ ISA DMA Controller
   \ AC97
   \ Codec
   \ USB

   \ Stop video refresh
   h# 4758 #  h# fe00.4000 #)  mov  \ Unlock DC registers
   h#    0 #  h# fe00.4004 #)  mov  \ Turn off access to display memory

   h# 4000.0e00 h# 1410 port-wl   \ Assert SLP_CLK_EN# 1 mS after SUSPA#
   h# 4000.4601 h# 1414 port-wl   \ Release SUSP# 5 mS after wakeup
   h# 4000.00a0 h# 1434 port-wl   \ Turn on WORK_AUX (== MAIN_ON) after 5 mS
   h# 4000.0001 h# 1438 port-wl   \ RESET_OUT turn on delay
   h# 0002.ffff h# 1454 port-wl   \ Clear wakeup type bits

   \ This is actually two 16-bit registers, but 16-bit writes don't work
   \ right (they corrupt other registers) due to a 5536 erratum.  
   h# 1840 port-rl  ( .s cr h# ffff bitset ) ax dx out

   \ The caller chooses the wakeup conditions, so we don't do it here
   \ h# 0100.ffff h# 1840 port-wl   \ Enable Power button wakeup, clear status bits

   wbinvd                                 \ Flush the cache
   h# 00ff.ff00  h# 2000.0018 bitclr-msr  \ Set refresh to 0, disabling GX refresh

   \ This is what the code below does, without the cache alignment elaborations
   \ h#         4. h# 2000.2004 set-msr     \ Enable memory controller clock gating
   \ h#      2000  h# 1848 port-wl          \ go to sleep

   \ Setup the register values in advance so the active instruction sequence
   \ is as short as possible, thus keeping all the activity in one cache line.
   h# 4. # dx mov # ax mov              \ Value to write to MSR
   h# 2000.2004 # cx mov                \ GLD_MSR_PM MSR number
   h# 2000 # bx mov                     \ Value to write to PM1_CNT register
   h# 1848 # di mov                     \ PM1_CNT I/O port number

   \ Align to a cache line boundary
   also forth
   begin  here asm-base - h# 1f and  while  h# 90 c,  repeat  \ Align with NOPs
   previous

   wrmsr                                \ Write GLD_MSR_PM to self-refresh memory
   di dx mov  bx ax mov  ax dx out      \ Write PM1_CNT to initial suspend

   begin again    \ Spin in this cache line while going down

\ Resume code
here resume-entry put-branch

\ Assumptions:
\   Processor is in protected mode
\   Running from a 32-bit identity-mapped code segment
\   Using physical addresses

\ char < 3f8 port-wb  begin  3fd port-rb 20 bitand  0<> until

   resume-data #  bp  mov

   cld

   \ MSR init
   h# 30 [bp]  si  mov   \ MSR table start address
   si          bx  mov
   h# 34 [bp]  bx  add   \ MSR table end address

   begin
      ax lods  ax cx  mov   \ msr#
      ax lods  ax dx  mov   \ msr.hi
      ax lods               \ msr.lo
      wrmsr
      si bx cmp
   = until

   h# 38 [bp]  si  lea    \ Save area

   ax lods  ax dx xchg  ax lods  ax dx xchg  h# 4c00.0014 wmsr  \ RSTPLL
   ax lods  ax dx xchg  ax lods  ax dx xchg
   1 bitset  h# 4c00.0015 wmsr  \ DOTPLL - reset to make it take the new value
   1 bitclr  h# 4c00.0015 wmsr  \ DOTPLL - release reset
   ax lods  ax dx xchg  ax lods  ax dx xchg  h# c000.2001 wmsr  \ Video output format
   ax lods  ax dx xchg  ax lods  ax dx xchg  h# c000.2011 wmsr  \ TFTP pad select

   h# 1038 #     dx  mov  \ Low bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      ax lods
      ax   dx  out  \ Write to GPIO control register
      4 #  dx  sub  \ Next port address
   loopne
   ax lods  h# 1040 # dx mov  ax dx out  \ Pos edge enable
   ax lods  h# 1044 # dx mov  ax dx out  \ Neg edge enable
   ax lods  h# 103c # dx mov  ax dx out  \ Low bank lock

   h# 10b8 #     dx  mov  \ High bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      ax lods
      ax   dx  out  \ Write to GPIO control register
      4 #  dx  sub  \ Next port address
   loopne
   ax lods  h# 10c0 # dx mov  ax dx out  \ Pos edge enable
   ax lods  h# 10c4 # dx mov  ax dx out  \ Neg edge enable
   ax lods  h# 10bc # dx mov  ax dx out  \ High bank lock

\   0 h# 1842 pw!   \ Disable power button during early startup

   \ Restore Interrupt controller setup
   al lods        al h# 20 # out    \ PIC1 ICW1
   al lods        al h# 21 # out    \ PIC1 ICW2
   al lods        al h# 21 # out    \ PIC1 ICW3
   al lods        al h# 21 # out    \ PIC1 ICW4
   al lods        al h# 20 # out    \ PIC1 OCW2
   h# c0 # al or  al h# 20 # out    \ PIC1 OCW2'
   al lods        al h# 20 # out    \ PIC1 OCW3

   al lods        al h# a0 # out    \ PIC2 ICW1
   al lods        al h# a1 # out    \ PIC2 ICW2
   al lods        al h# a1 # out    \ PIC2 ICW3
   al lods        al h# a1 # out    \ PIC2 ICW4
   al lods        al h# a0 # out    \ PIC2 OCW2
   h# c0 # al or  al h# a0 # out    \ PIC2 OCW2'
   al lods        al h# a0 # out    \ PIC2 OCW3

   al lods  al  h# 21 #  out   \ PIC1 OCW1 (interrupt mask)
   al lods  al  h# a1 #  out   \ PIC2 OCW1 (interrupt mask)

   al lods  h# 4d0 # dx mov  al dx out   \ Edge/level low
   al lods  h# 4d1 # dx mov  al dx out   \ Edge/level high

   \ Restore PIT (timer)
   h# 30 # al mov  al h# 43 # out  \ Load LSB,MSB for counter 0
   al lods  al h# 40 out
   al lods  al h# 40 out
   h# 70 # al mov  al h# 43 # out  \ Load LSB,MSB for counter 1
   al lods  al h# 41 out
   al lods  al h# 41 out
   h# b0 # al mov  al h# 43 # out  \ Load LSB,MSB for counter 2
   al lods  al h# 42 # out
   al lods  al h# 42 # out
   al lods  \ Command word for counter 0
   al lods  \ Command word for counter 1
   al lods  \ Command word for counter 2
   al lods  al h# 43 # out
   al lods  al h# 61 # out
   al lods  h# 5140.0037 wmsr   \ PIT Count Enable MSR - high bits irrelevant

   \ SMBUS controller
   h# 18b3 # dx mov  \ SMBUS base port
   al lods          al dx out  \ Reg 3
   al lods  dx inc  al dx out  \ Reg 4
   al lods  dx inc  al dx out  \ Reg 5 without the enable bit
   al lods  dx inc  al dx out  \ Reg 6
   al lods  dx dec  al dx out  \ Reg 5 with the enable bit

   \ MFGPTs 0-5.  MFGPT 6 and 7 are in the standby domain, live during suspend
   h# 1800 # dx mov  \ MFGPT base port
   h# 18 # cx mov
   begin
      op: ax lods
      op: ax dx out
      dx inc  dx inc
   loopa

   \ AC97
   \ Codec

   \ h# 8000 h# 4000.0000 or h# 1440 pl!  \ Fail-safe delay

   \ Restore CaFe configuration

   h# 6010 config-setup  ax lods  ax dx out        \ NAND BAR
   ax bx mov                                       \ Base address
   6  h# 6004 config-ww                            \ Enable access
   ax lods  ax  h# 24 [bx]  mov                    \ NAND Timing 1
   ax lods  ax  h# 28 [bx]  mov                    \ NAND Timing 2
   ax lods  ax  h# 2c [bx]  mov                    \ NAND Timing 3
   h# 6004 config-setup  ax lods  op: ax dx out    \ NAND enables

   h# 6110 config-setup  ax lods  ax dx out        \ SDHCI BAR
   ax bx mov                                       \ Base address
   6  h# 6104 config-ww                            \ Enable access
   ax lods  ax  h# 3038 [bx]  mov                  \ GPIO Config
   ax lods  ax  h# 315c [bx]  mov                  \ GPIO Data
   \ The next two values can't be saved/restored; the registers aren't readable
   op: h# 0004 #  h# 6a [bx]  mov                  \ Magic recipe from Marvell
   op: h# 7fff #  h# 60 [bx]  mov                  \ Magic recipe from Marvell
   h# 6104 config-setup  ax lods  op: ax dx out    \ SDHCI enables

   h# 6210 config-setup  ax lods  ax dx out        \ Camera BAR
   h# 6204 config-setup  ax lods  op: ax dx out    \ Camera enables

   \ Display stuff
   h# 4758 #  h# fe00.4000 #)  mov  \ Unlock display controller registers

   h# 1808 rmsr              \ Get default region config register - low in ax
   d#  8 # ax shr            \ Discard region type bits
   d# 12 # ax shl            \ Convert page number to address
   ax  h# fe00.4088 #)  mov  \ DV_CTL register - sets framebuffer phys base

   h# fd00.0000 #  h# fe00.4084 #)  mov   \ GLIU0 Memory offset
   h# fd00.0000 #  h# fe00.004c #)  mov   \ GP base
   h# fd80.0000 #  h# fe00.8460 #)  mov   \ Flat panel base

   \ There is a lot of other stuff that must be done to turn on the
   \ video - but we will let the gx driver take care of that.

   \ USB Power-to-Port assignment
   h# 3ab #  h# efc00000 #) mov
   h#   2 #  h# efc00004 #) mov

   \ XXX keyboard init
   \ DCON fiddling
   \ USB

   h# 20 [bp]  ax mov  ax cr4 mov  
   h# 1c [bp]  ax mov  ax cr3 mov  
   h# 18 [bp]  ax mov  ax cr0 mov  

   \ Force the paging enable to take place
   h# eb asm8,  0 asm8,    \ jmp to next location to enable paging
   \ here asm-base - 5 +  suspend-base + #)  jmp

   h# 10 [bp]  lgdt        \ Global descriptor table register
   h#  a [bp]  lidt        \ Interrupt descriptor table register
   h#  8 [bp]  lldt        \ Local descriptor table register
\  h#  6 [bp]  ltr         \ Task register

\  char > 3f8 port-wb  begin  3fd port-rb 20 bitand  0<> until

   0 [bp]  sp  lss
   gs pop
   fs pop
   es pop
   ds pop
   popf
   popa
   ret
end-code

writing resume.di
suspend-entry here over -  0  " resume"  write-dropin
ofd @ fclose
