\ See license at end of file
purpose: Low-level code to handle suspend/resume from RAM

command: &builder &this
build-now

\needs start-assembling  fload ${BP}/cpu/x86/asmtools.fth
\needs write-dropin      fload ${BP}/forth/lib/mkdropin.fth

\ create debug-startup

hex

\ fload ${BP}/cpu/x86/pc/report.fth		\ Startup reports for debugging

fload ${BP}/cpu/x86/pc/olpc/config.fth		\ Configuration defines

fload ${BP}/cpu/x86/pc/olpc/startmacros.fth

\ This code will be copied to RAM at suspend-base

start-assembling                                \ Turn on the target assembler
protected-mode

label suspend-entry   \ h# f.0000
   e9 c,  0 ,         \ To be patched later
   nop nop nop        \ Pad to offset 8

label resume-entry    \ h# f.0008
   e9 c,  0 ,         \ To be patched later
   nop nop nop        \ Pad to offset 10

\ Suspend code - called as a subroutine, with return address on the stack
here suspend-entry put-branch
   pusha
   pushf
   ds push
   es push
   fs push
   gs push

   resume-data #  bp  mov

   sp      0 [bp]  mov     \ SP part of SP:SS full pointer

   ss push  ax pop         \ SS in ax
   op: ax  4 [bp]  mov     \ SS part of SP:SS full pointer

   h#  6 [bp]  str         \ Task register
   h#  8 [bp]  sldt        \ Local descriptor table register
   h#  a [bp]  sidt        \ Interrupt descriptor table register
   h# 10 [bp]  sgdt        \ Global descriptor table register

   cr0 ax mov  ax  h# 18 [bp]  mov
   cr3 ax mov  ax  h# 1c [bp]  mov
   cr4 ax mov  ax  h# 20 [bp]  mov

   cld
   h# 38 [bp]  di  lea    \ Save area

   \ Video MSRs that change between VGA and flat panel
   h# 4c00.0014 rmsr  ax stos  dx ax mov  ax stos   \ RSTPLL
   h# 4c00.0015 rmsr  ax stos  dx ax mov  ax stos   \ DOTPLL
   h# c000.2001 rmsr  ax stos  dx ax mov  ax stos   \ Video output format
   h# c000.2011 rmsr  ax stos  dx ax mov  ax stos   \ TFTP pad select

   \ Save the GPIO setup   
   \ We do this in top-down order to configure the AUX select
   \ registers before setting the output enables and values.

   h# 1038 #     dx  mov  \ Low bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      dx  ax   in   \ Read GPIO control register
      ax stos       \ Save
      4 #  dx  sub  \ Next port address
   loopne

   h# 1040 # dx mov  dx ax in  ax stos  \ Pos edge enable
   h# 1044 # dx mov  dx ax in  ax stos  \ Neg edge enable
   h# 103c # dx mov  dx ax in  ax stos  \ Low bank lock

   h# 10b8 #     dx  mov  \ High bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      ax   dx  in   \ Read GPIO control register
      ax stos       \ Save
      4 #  dx  sub  \ Next port address
   loopne

   h# 10c0 # dx mov  dx ax in  ax stos  \ Pos edge enable
   h# 10c4 # dx mov  dx ax in  ax stos  \ Neg edge enable
   h# 10bc # dx mov  dx ax in  ax stos  \ High bank lock

\ XXX need to do the shadow thing for the PIT too - 51400036
\ XXX and the DMA controller

   h# 5140.0034 wmsr         \ Reset PIC shadow pointer (data is irrelevant)
   rdmsr  al stos            \ PIC1 ICW1
   rdmsr  al stos            \ PIC1 ICW2
   rdmsr  al stos            \ PIC1 ICW3
   rdmsr  al stos            \ PIC1 ICW4
   rdmsr  al stos            \ PIC1 OCW2
   rdmsr  al stos            \ PIC1 OCW3

   rdmsr  al stos            \ PIC2 ICW1
   rdmsr  al stos            \ PIC2 ICW2
   rdmsr  al stos            \ PIC2 ICW3
   rdmsr  al stos            \ PIC2 ICW4
   rdmsr  al stos            \ PIC2 OCW2
   rdmsr  al stos            \ PIC2 OCW3

   h# 21 # al in  al stos    \ PIC1 OCW1 (interrupt mask)
   h# a1 # al in  al stos    \ PIC2 OCW1 (interrupt mask)

   h# 4d0 # dx mov  dx al in  al stos   \ Edge/level low
   h# 4d1 # dx mov  dx al in  al stos   \ Edge/level high

   h# 5140.0036 wmsr       \ Reset PIT shadow pointer (data is irrelevant)
   rdmsr  al stos            \ PIT Counter 0 LSB
   rdmsr  al stos            \ PIT Counter 0 MSB
   rdmsr  al stos            \ PIT Counter 1 LSB
   rdmsr  al stos            \ PIT Counter 1 MSB
   rdmsr  al stos            \ PIT Counter 2 LSB
   rdmsr  al stos            \ PIT Counter 2 MSB
   rdmsr  al stos            \ PIT Counter 0 Command Word - not sure how this works
   rdmsr  al stos            \ PIT Counter 1 Command Word
   rdmsr  al stos            \ PIT Counter 2 Command Word
   h# 43 # al in  al stos    \ Read back register 43 directly
   h# 61 # al in  al stos    \ Read back register 43 directly
   h# 5140.0037 rmsr  al stos  \ PIT Count Enable MSR

   \ SMBUS controller
   h# 18b3 # dx mov  \ SMBUS base port
           dx al in   al stos   \ Reg 3
   dx inc  dx al in   al stos   \ Reg 4
   dx inc  dx al in   al bl mov  h# fe # al and  al stos   \ Reg 5 w/o enable bit
   dx inc  dx al in   al stos   \ Reg 6
           bl al mov  al stos   \ Reg 5 with enable bit

   \ MFGPTs 0-5.  MFGPT 6 and 7 are in the standby domain, live during suspend
   h# 1800 # dx mov  \ MFGPT base port
   h# 18 # cx mov    \ Save registers up to h# 30.
   begin
      op: dx ax in
      op: ax stos
      dx inc  dx inc
   loopa

   \ AC97
   \ Codec
   \ USB

   h# 4000.0e00 h# 1410 port-wl   \ Assert SLP_CLK_EN# 1 mS after SUSPA#
   h# 4000.460a h# 1414 port-wl   \ Release SUSP# 5 mS after wakeup
   h# 4000.00a0 h# 1434 port-wl   \ Turn on WORK_AUX (== MAIN_ON) after 5 mS
   h# 4000.0001 h# 1438 port-wl   \ RESET_OUT turn on delay
   h# 0002.ffff h# 1454 port-wl   \ Clear wakeup type bits

   \ This is actually two 16-bit registers, but 16-bit writes don't work
   \ right (they corrupt other registers) due to a 5536 erratum.  
   h# 1840 port-rl  ( .s cr h# ffff bitset ) ax dx out
\   h# 0100.ffff h# 1840 port-wl   \ Enable Power button wakeup, clear status bits

   wbinvd                                 \ Flush the cache
   \ h# x.y.  h# 2000.0020 bitclr-msr  \ PM sensitivity counter
   h# 00ff.ff00  h# 2000.0018 bitclr-msr  \ Set refresh to 0, disabling GX refresh
   h#         4. h# 2000.2004 set-msr     \ Enable memory controller clock gating
   h#      2000  h# 1848 port-wl          \ go to sleep

   begin again

\ Resume code
here resume-entry put-branch

\ Assumptions:
\   Processor is in protected mode
\   Running from a 32-bit identity-mapped code segment
\   Using physical addresses

  char < 3f8 port-wb  begin  3fd port-rb 20 bitand  0<> until

   resume-data #  bp  mov

   cld

   \ MSR init
   h# 30 [bp]  si  mov   \ MSR table start address
   si          bx  mov
   h# 34 [bp]  bx  add   \ MSR table end address

   begin
      ax lods  ax cx  mov   \ msr#
      ax lods  ax dx  mov   \ msr.hi
      ax lods               \ msr.lo
      wrmsr
      si bx cmp
   = until

   h# 38 [bp]  si  lea    \ Save area

   ax lods  ax dx xchg  ax lods  ax dx xchg  h# 4c00.0014 wmsr  \ RSTPLL
   ax lods  ax dx xchg  ax lods  ax dx xchg
   1 bitset  h# 4c00.0015 wmsr  \ DOTPLL - reset to make it take the new value
   1 bitclr  h# 4c00.0015 wmsr  \ DOTPLL - release reset
   ax lods  ax dx xchg  ax lods  ax dx xchg  h# c000.2001 wmsr  \ Video output format
   ax lods  ax dx xchg  ax lods  ax dx xchg  h# c000.2011 wmsr  \ TFTP pad select

   h# 1038 #     dx  mov  \ Low bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      ax lods
      ax   dx  out  \ Write to GPIO control register
      4 #  dx  sub  \ Next port address
   loopne
   ax lods  h# 1040 # dx mov  ax dx out  \ Pos edge enable
   ax lods  h# 1044 # dx mov  ax dx out  \ Neg edge enable
   ax lods  h# 103c # dx mov  ax dx out  \ Low bank lock

   h# 10b8 #     dx  mov  \ High bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      ax lods
      ax   dx  out  \ Write to GPIO control register
      4 #  dx  sub  \ Next port address
   loopne
   ax lods  h# 10c0 # dx mov  ax dx out  \ Pos edge enable
   ax lods  h# 10c4 # dx mov  ax dx out  \ Neg edge enable
   ax lods  h# 10bc # dx mov  ax dx out  \ High bank lock

\   0 h# 1842 pw!   \ Disable power button during early startup

   \ Restore Interrupt controller setup
   al lods        al h# 20 # out    \ PIC1 ICW1
   al lods        al h# 21 # out    \ PIC1 ICW2
   al lods        al h# 21 # out    \ PIC1 ICW3
   al lods        al h# 21 # out    \ PIC1 ICW4
   al lods        al h# 20 # out    \ PIC1 OCW2
   h# c0 # al or  al h# 20 # out    \ PIC1 OCW2'
   al lods        al h# 20 # out    \ PIC1 OCW3

   al lods        al h# a0 # out    \ PIC2 ICW1
   al lods        al h# a1 # out    \ PIC2 ICW2
   al lods        al h# a1 # out    \ PIC2 ICW3
   al lods        al h# a1 # out    \ PIC2 ICW4
   al lods        al h# a0 # out    \ PIC2 OCW2
   h# c0 # al or  al h# a0 # out    \ PIC2 OCW2'
   al lods        al h# a0 # out    \ PIC2 OCW3

   al lods  al  h# 21 #  out   \ PIC1 OCW1 (interrupt mask)
   al lods  al  h# a1 #  out   \ PIC2 OCW1 (interrupt mask)

   al lods  h# 4d0 # dx mov  al dx out   \ Edge/level low
   al lods  h# 4d1 # dx mov  al dx out   \ Edge/level high

   \ Restore PIT (timer)
   h# 30 # al mov  al h# 43 # out  \ Load LSB,MSB for counter 0
   al lods  al h# 40 out
   al lods  al h# 40 out
   h# 70 # al mov  al h# 43 # out  \ Load LSB,MSB for counter 1
   al lods  al h# 41 out
   al lods  al h# 41 out
   h# b0 # al mov  al h# 43 # out  \ Load LSB,MSB for counter 2
   al lods  al h# 42 # out
   al lods  al h# 42 # out
   al lods  \ Command word for counter 0
   al lods  \ Command word for counter 1
   al lods  \ Command word for counter 2
   al lods  al h# 43 # out
   al lods  al h# 61 # out
   al lods  h# 5140.0037 wmsr   \ PIT Count Enable MSR - high bits irrelevant

   \ SMBUS controller
   h# 18b3 # dx mov  \ SMBUS base port
   al lods          al dx out  \ Reg 3
   al lods  dx inc  al dx out  \ Reg 4
   al lods  dx inc  al dx out  \ Reg 5 without the enable bit
   al lods  dx inc  al dx out  \ Reg 6
   al lods  dx dec  al dx out  \ Reg 5 with the enable bit

   \ MFGPTs 0-5.  MFGPT 6 and 7 are in the standby domain, live during suspend
   h# 1800 # dx mov  \ MFGPT base port
   h# 18 # cx mov
   begin
      op: ax lods
      op: ax dx out
      dx inc  dx inc
   loopa

   \ AC97
   \ Codec
   \ USB

   \ h# 8000 h# 4000.0000 or h# 1440 pl!  \ Fail-safe delay

1 [if]
   \ Assign CaFe base addresses
   h# fe00c000 h# 6010 config-wl  \ NAND FLASH base address
   h# fe010000 h# 6110 config-wl  \ SD base address
   h# fe014000 h# 6210 config-wl  \ Camera controller base address
\ XXX need to set CaFe timing too.
[then]

   \ Display stuff
   h# 4758 #  h# fe00.4000 #)  mov  \ Unlock display controller registers

   h# 1808 rmsr              \ Get default region config register - low in ax
   d#  8 # ax shr            \ Discard region type bits
   d# 12 # ax shl            \ Convert page number to address
   ax  h# fe00.4088 #)  mov  \ DV_CTL register - sets framebuffer phys base

   h# fd00.0000 #  h# fe00.4084 #)  mov   \ GLIU0 Memory offset
   h# fd00.0000 #  h# fe00.004c #)  mov   \ GP base
   h# fd80.0000 #  h# fe00.8460 #)  mov   \ Flat panel base

   \ There is a lot of other stuff that must be done to turn on the
   \ video - but we will let the gx driver take care of that.

   \ USB Power-to-Port assignment
   h# 3ab #  h# efc00000 #) mov
   h#   2 #  h# efc00004 #) mov

   \ XXX keyboard init
   \ DCON fiddling
   \ USB

   h# 20 [bp]  ax mov  ax cr4 mov  
   h# 1c [bp]  ax mov  ax cr3 mov  
   h# 18 [bp]  ax mov  ax cr0 mov  

   \ Force the paging enable to take place
   h# eb asm8,  0 asm8,    \ jmp to next location to enable paging
   \ here asm-base - 5 +  suspend-base + #)  jmp

   h# 10 [bp]  lgdt        \ Global descriptor table register
   h#  a [bp]  lidt        \ Interrupt descriptor table register
   h#  8 [bp]  lldt        \ Local descriptor table register
\  h#  6 [bp]  ltr         \ Task register

  char > 3f8 port-wb  begin  3fd port-rb 20 bitand  0<> until

   0 [bp]  sp  lss
   gs pop
   fs pop
   es pop
   ds pop
   popf
   popa
   ret
end-code

writing resume.di
suspend-entry here over -  0  " resume"  write-dropin
ofd @ fclose
