\ See license at end of file
purpose: Low-level code to handle suspend/resume from RAM

command: &builder &this
build-now

\needs start-assembling  fload ${BP}/cpu/x86/asmtools.fth
\needs write-dropin      fload ${BP}/forth/lib/mkdropin.fth

\ create debug-startup

hex

\ fload ${BP}/cpu/x86/pc/report.fth		\ Startup reports for debugging

fload ${BP}/cpu/x86/pc/olpc/config.fth		\ Configuration defines

fload ${BP}/cpu/x86/pc/olpc/startmacros.fth

h# 526f7553 constant suspended   \ 'StoR'

resume-signature h# 10 + constant resume-data

\ This code will be copied to RAM at resume-base

start-assembling                                \ Turn on the target assembler
protected-mode

label suspend-entry   \ h# f.0000
   e9 c,  0 ,         \ To be patched later
   nop nop nop        \ Pad to offset 8

label resume-entry    \ h# f.0008
   e9 c,  0 ,         \ To be patched later
   nop nop nop        \ Pad to offset 10

\ Suspend code - called as a subroutine, with return address on the stack
here suspend-entry put-branch
   pusha
   pushf
   ds push
   es push
   fs push
   gs push

   resume-data #  bp  mov

   sp      0 [bp]  mov     \ SP part of SP:SS full pointer

   ss push  ax pop         \ SS in ax
   op: ax  4 [bp]  mov     \ SS part of SP:SS full pointer

   h#  6 [bp]  str         \ Task register
   h#  8 [bp]  sldt        \ Local descriptor table register
   h#  a [bp]  sidt        \ Interrupt descriptor table register
   h# 10 [bp]  sgdt        \ Global descriptor table register

   cr0 ax mov  ax  h# 18 [bp]  mov
   cr3 ax mov  ax  h# 1c [bp]  mov
   cr4 ax mov  ax  h# 20 [bp]  mov

   \ Save the GPIO setup   
   cld
   h# 38 [bp]  di  lea    \ GPIO save area

   h# 1000 #     dx  mov  \ Low bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      dx  ax   in   \ Read GPIO control register
      ax stos       \ Save
      4 #  dx  add  \ Next port address
   loopne

   h# 1040 # dx mov  dx ax in  ax stos  \ Pos edge enable
   h# 1044 # dx mov  dx ax in  ax stos  \ Neg edge enable
   h# 103c # dx mov  dx ax in  ax stos  \ Low bank lock

   h# 1080 #     dx  mov  \ High bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      ax   dx  in   \ Read GPIO control register
      ax stos       \ Save
      4 #  dx  add  \ Next port address
   loopne

   h# 10c0 # dx mov  dx ax in  ax stos  \ Pos edge enable
   h# 10c4 # dx mov  dx ax in  ax stos  \ Neg edge enable
   h# 10bc # dx mov  dx ax in  ax stos  \ High bank lock

   h# 5140.0034 #  cx  mov   \ MSR number
   wrmsr                     \ Reset PIC shadow pointer (data is irrelevant)
   rdmsr  al stos            \ PIC1 ICW1
   rdmsr  al stos            \ PIC1 ICW2
   rdmsr  al stos            \ PIC1 ICW3
   rdmsr  al stos            \ PIC1 ICW4
   rdmsr  al stos            \ PIC1 OCW2
   rdmsr  al stos            \ PIC1 OCW3

   rdmsr  al stos            \ PIC2 ICW1
   rdmsr  al stos            \ PIC2 ICW2
   rdmsr  al stos            \ PIC2 ICW3
   rdmsr  al stos            \ PIC2 ICW4
   rdmsr  al stos            \ PIC2 OCW2
   rdmsr  al stos            \ PIC2 OCW3

   h# 21 # al in  al stos    \ PIC1 OCW1 (interrupt mask)
   h# a1 # al in  al stos    \ PIC2 OCW1 (interrupt mask)

   suspended #  resume-signature #)  mov  \ Set suspended marker

   h# 4000.0e00 h# 1410 port-wl   \ Assert SLP_CLK_EN# 1 mS after SUSPA#
   h# 4000.4601 h# 1414 port-wl   \ Release SUSP# 5 mS after wakeup
   h# 4000.00a0 h# 1434 port-wl   \ Turn off WORK_AUX (== MAIN_ON) after 5 mS
   h# 0002.ffff h# 1454 port-wl   \ Clear wakeup type bits

   \ This is actually two 16-bit registers, but 16-bit writes don't work
   \ right due to a 5536 erratum.  (The corrupt other registers)
   h# 0100.ffff h# 1840 port-wl   \ Enable Power button wakeup, clear status bits

   wbinvd                                 \ Flush the cache
   \ h# x.y.  h# 2000.0020 bitclr-msr  \ PM sensitivity counter
   h# 00ff.ff00  h# 2000.0018 bitclr-msr  \ Set refresh to 0, disabling GX refresh
   h#         4. h# 2000.2004 set-msr     \ Enable memory controller clock gating
   h#      2000  h# 1848 port-wl          \ go to sleep

   begin again

\ Resume code
here resume-entry put-branch

\ Assumptions:
\   Processor is in protected mode
\   Running from a 32-bit identity-mapped code segment
\   Using physical addresses

   0 #  resume-signature #) mov    \ Clear suspended marker

   resume-data #  bp  mov

   cld

   \ MSR init
   h# 30 [bp]  si  mov   \ MSR table start address
   h# 34 [bp]  bx  mov   \ MSR table end address

   begin
      ax lods  ax cx  mov   \ msr#
      ax lods  ax dx  mov   \ msr.hi
      ax lods               \ msr.lo
      wrmsr
      si bx cmp
   = until

   h# 38 [bp]  si  lea    \ GPIO save area

   h# 1000 #     dx  mov  \ Low bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      ax lods
      ax   dx  out  \ Write to GPIO control register
      4 #  dx  add  \ Next port address
   loopne
   ax lods  h# 1040 # dx mov  ax dx out  \ Pos edge enable
   ax lods  h# 1044 # dx mov  ax dx out  \ Neg edge enable
   ax lods  h# 103c # dx mov  ax dx out  \ Low bank lock

   h# 1080 #     dx  mov  \ High bank - first contiguous GPIO register
   h# 3c /l / #  cx  mov  \ Register count (stop at lock register)
   begin
      ax lods
      ax   dx  out  \ Write to GPIO control register
      4 #  dx  add  \ Next port address
   loopne
   ax lods  h# 10c0 # dx mov  ax dx out  \ Pos edge enable
   ax lods  h# 10c4 # dx mov  ax dx out  \ Neg edge enable
   ax lods  h# 10bc # dx mov  ax dx out  \ High bank lock

\   0 h# 1842 pw!   \ Disable power button during early startup

   h# 20 h# 4d0 port-wb         \ IRQ5 (AC-97) level triggered
   h# 0c h# 4d1 port-wb         \ IRQA (USB) and IRQB (GXFB) level triggered

   \ Restore Interrupt controller setup
   al lods        al h# 20 # out    \ PIC1 ICW1
   al lods        al h# 21 # out    \ PIC1 ICW2
   al lods        al h# 21 # out    \ PIC1 ICW3
   al lods        al h# 21 # out    \ PIC1 ICW4
   al lods        al h# 20 # out    \ PIC1 OCW2
   h# c0 # al or  al h# 20 # out    \ PIC1 OCW2'
   al lods        al h# 20 # out    \ PIC1 OCW3

   al lods        al h# a0 # out    \ PIC2 ICW1
   al lods        al h# a1 # out    \ PIC2 ICW2
   al lods        al h# a1 # out    \ PIC2 ICW3
   al lods        al h# a1 # out    \ PIC2 ICW4
   al lods        al h# a0 # out    \ PIC2 OCW2
   h# c0 # al or  al h# a0 # out    \ PIC2 OCW2'
   al lods        al h# a0 # out    \ PIC2 OCW3

   al lods  al  h# 21 #  out   \ PIC1 OCW1 (interrupt mask)
   al lods  al  h# a1 #  out   \ PIC2 OCW1 (interrupt mask)

   \ 5536 NAND FLASH ...  ???
   \ h# 8000 h# 4000.0000 or h# 1440 pl!  \ Fail-safe delay

   \ Assign CaFe base addresses
   h# fe00c000 6010 config-wl  \ NAND FLASH base address
   h# fe010000 6110 config-wl  \ SD base address
   h# fe014000 6210 config-wl  \ Camera controller base address
\ XXX need to set CaFe timing too.

   \ Display stuff
   h# 4758 #  h# fe00.4000 #)  mov  \ Unlock display controller registers

   h# 1808 rmsr              \ Get default region config register - low in ax
   d#  8 # ax shr            \ Discard region type bits
   d# 12 # ax shl            \ Convert page number to address
   ax  h# fe00.4088 #)  mov  \ DV_CTL register - sets framebuffer phys base

   h# fd00.0000 #  h# fe00.4084 #)  mov   \ GLIU0 Memory offset
   h# fd00.0000 #  h# fe00.004c #)  mov   \ GP base
   h# fd80.0000 #  h# fe00.8460 #)  mov   \ Flat panel base

   \ There is a lot of other stuff that must be done to turn on the
   \ video - but we will let the gx driver take care of that.

   \ USB Power-to-Port assignment
   h# 3ab #  h# efc00000 #) mov
   h#   2 #  h# efc00004 #) mov

   \ XXX keyboard init
   \ DCON fiddling
   \ USB

   h# 20 [bp]  ax mov  ax cr4 mov  
   h# 1c [bp]  ax mov  ax cr3 mov  
   h# 18 [bp]  ax mov  ax cr0 mov  

   \ Force the paging enable to take place
   h# eb asm8,  0 asm8,    \ jmp to next location to enable paging
   \ here asm-base - 5 +  resume-base + #)  jmp

   h# 10 [bp]  lgdt        \ Global descriptor table register
   h#  a [bp]  lidt        \ Interrupt descriptor table register
   h#  8 [bp]  lldt        \ Local descriptor table register
   h#  6 [bp]  ltr         \ Task register

   0 [bp]  sp  lss
   gs pop
   fs pop
   es pop
   ds pop
   popf
   popa
   ret
end-code

writing resume.di
suspend-entry here over -  0  " resume"  write-dropin
ofd @ fclose
